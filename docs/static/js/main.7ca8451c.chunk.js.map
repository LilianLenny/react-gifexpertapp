{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","onFocus","getGifs","category","a","url","encodeURI","fetch","response","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"yMAOaA,EAAc,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAE1B,EAAoCC,mBAAS,aAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KA2BA,OACI,sBAAMC,SAjBW,SAACC,GAChBA,EAAEC,iBAKGJ,EAAWK,OAAOC,OADM,IAI3BR,GAAe,SAAAS,GAAI,OAAMP,GAAN,mBAAqBO,OAExCN,EAAc,MAMlB,SACI,uBACAO,KAAK,OACLC,MAAQT,EACRU,SA1BkB,SAACP,GAEvBF,EAAcE,EAAEQ,OAAOF,QAyBnBG,QA/BiB,SAACT,GACtBF,EAAc,U,+BCVTY,EAAO,uCAAG,WAAQC,GAAR,uBAAAC,EAAA,6DAEbC,EAFa,iDAEoCC,UAAUH,GAF9C,+DAGII,MAAOF,GAHX,cAGbG,EAHa,gBAIEA,EAASC,OAJX,uBAIZC,EAJY,EAIZA,KAEDC,EAAOD,EAAKE,KAAK,SAAAC,GAAQ,IAAD,EACzB,MAAO,CACFC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAVzB,kBAiBZM,GAjBY,4CAAH,sDCAPO,EAAc,SAAC,GAAuB,EAArBJ,GAAsB,IAAlBC,EAAiB,EAAjBA,MAAOV,EAAU,EAAVA,IAIrC,OACI,sBAAKc,UAAU,yCAAf,UACG,qBAAKC,IAAKf,EAAKgB,IAAKN,IACpB,6BAAKA,QCDHO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAEtB,ECDwB,SAAEA,GAE1B,IAIA,EAA0Bf,mBAJA,CACtBsB,KAAM,GACNa,SAAS,IAEb,mBAAOC,EAAP,KAAcC,EAAd,KAgBA,OAbAC,qBAAU,WAENxB,EAASC,GACRwB,MAAM,SAAAC,GACHH,EAAS,CACLf,KAAMkB,EACNL,SAAS,SAIlB,CAAEpB,IAGEqB,EDrB0BK,CAAe1B,GAAnCa,EAAb,EAAQN,KAAaa,EAArB,EAAqBA,QAKrB,OACI,qCACI,oBAAIJ,UAAU,oCAAd,SAAoDhB,IAElDoB,GAAW,mBAAGJ,UAAU,mCAAb,wBAEb,qBAAKA,UAAU,YAAf,SAEQH,EAAOJ,KAAK,SAAAC,GAAG,OACX,cAAC,EAAD,eAISA,GAHGA,EAAIC,aEuCzBgB,EA1DM,WASjB,IACA,EAAoC1C,mBADf,CAAC,cACtB,mBAAO2C,EAAP,KAAmB5C,EAAnB,KAkBA,OACI,qCACE,8CACA,cAAC,EAAD,CAAaA,cAAkBA,IAI/B,oBAAIgC,UAAU,kBAAd,SASMY,EAAWnB,KAAK,SAAAT,GAAQ,OACpB,cAAC,EAAD,CAEMA,SAAaA,GADLA,Y,MC5ClC6B,IAASC,OACP,cAAC,EAAD,IACAC,SAASC,eAAe,W","file":"static/js/main.7ca8451c.chunk.js","sourcesContent":["import React, {useState} from 'react';\r\n\r\nimport PropTypes from 'prop-types'; \r\n//estado del input\r\n\r\n\r\n\r\nexport const AddCategory = ( {setCategories} ) => {\r\n    \r\n    const [inputValue, setInputValue] = useState('Buscar...'); //si vacio inputValue es undefined si lo ponemos useState('') será un string vacio y ya no dará error\r\n   \r\n    const handleInputClean = (e) => {\r\n        setInputValue(''); \r\n    }\r\n\r\n    const handleInputChange = (e) => {\r\n        // console.log(e.target.value);\r\n        setInputValue(e.target.value); \r\n    }\r\n\r\n    const handleSubmit = (e) => {\r\n          e.preventDefault(); //prevenimos el comportamiento normal del formulario\r\n          //console.log('Submit Hecho!!!');\r\n\r\n          //Validación submit\r\n          const mayorQueNumeroLetras = 2\r\n          if ( inputValue.trim().length > mayorQueNumeroLetras ){\r\n            \r\n            //Aquí llamamos a setCategories (nos comunicamos con el componente) en el properties de AddCategory\r\n            setCategories( cats =>  [inputValue, ...cats ] );\r\n\r\n            setInputValue(''); //para que no haga un doble posteo\r\n\r\n          }\r\n    }\r\n\r\n    return (\r\n        <form onSubmit= {handleSubmit}>\r\n            <input \r\n            type='text'\r\n            value={ inputValue }\r\n            onChange = { handleInputChange }\r\n            onFocus  = { handleInputClean }\r\n            />\r\n        </form>\r\n    )\r\n}\r\n\r\n//Un pequeño modo de hacer que el campo setCategories sea un requerido (en GifExpertApp el componente debe llevar setCategories como argumento)\r\nAddCategory.propTypes = { setCategories: PropTypes.func.isRequired }","\r\n\r\nexport const getGifs = async ( category ) => {\r\n    //hacemos una peticion http en javascript actual (lo que sustituye a una llamada ajax) \r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI(category) }&limit=10&api_key=UKGt1n2PXD3ff2UYj0hN25czZ0pd1m9K`;\r\n    const response = await fetch (url);\r\n    const {data} = await response.json(); \r\n\r\n    const gifs = data.map( img => {\r\n         return {\r\n              id: img.id,\r\n              title: img.title,\r\n              url: img.images?.downsized_medium.url //ponemos la interrogación (condición) para preguntar que si vienen las imagenes entonces la utilice\r\n         }\r\n    });\r\n\r\n    //console.log(data);  \r\n    // console.log(gifs);\r\n    // setImages(gifs);\r\n    return gifs;\r\n\r\n }\r\n","import React from 'react'\r\n\r\nexport const GifGridItem = ( {id, title, url} ) => {\r\n    \r\n    // console.log (id, title, url);\r\n\r\n    return (\r\n        <div className='card animate__animated animate__fadeIn'>\r\n           <img src={url} alt={title}/>\r\n           <h4>{title}</h4>\r\n        </div>\r\n    )\r\n}\r\n","//COMPONENTE: ES UNA COLECCION DE TODOS LOS ELEMENTOS QUE COINCIDEN CON ESA CATEGORIA\r\n\r\n//import React, { useState, useEffect } from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\n\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\n\r\nexport const GifGrid = ( {category} ) => {\r\n\r\n    const { data:images, loading } = useFetchGifs ( category );\r\n    \r\n    //console.log(loading);\r\n\r\n\r\n    return (\r\n        <>\r\n            <h3 className='animate__animated animate__fadeIn'>{ category }</h3>\r\n\r\n            { loading && <p className='animate__animated animate__flash'>Loading...</p>  }\r\n           \r\n            <div className='card-grid'> \r\n                {\r\n                    images.map( img =>  (\r\n                        <GifGridItem \r\n                            key = { img.id }\r\n                            // img = { img } \r\n                            //Mejor usar esto de aqui abajo\r\n                            {... img}\r\n                        />\r\n                    ))\r\n                }    \r\n            </div>\r\n            \r\n        </>\r\n    )\r\n}\r\n","//Esto es un custom hook que no es otra cosa que una función \r\n//Un Hook personalizado es una función de JavaScript cuyo nombre comienza con ”use” y que puede llamar a otros Hooks\r\n//Un custom hook funciona como si fueran un funtional component\r\n\r\nimport { useState, useEffect } from 'react';\r\n\r\nimport { getGifs} from '../helpers/getGifs';\r\n\r\n\r\nexport const useFetchGifs = ( category ) => {\r\n    \r\n    const initialState     =  {\r\n        data: [],\r\n        loading: true\r\n    }\r\n    const [state, setState] = useState(initialState);\r\n\r\n\r\n    useEffect(() => {\r\n       \r\n        getGifs( category )\r\n        .then( imgs => { //esto es una promesa. Un \"Effect\" no puede ser async\r\n            setState({\r\n                data: imgs,\r\n                loading: false\r\n            });\r\n        }); \r\n       \r\n    }, [ category ])\r\n\r\n    \r\n    return state; //{data:[], loading:true}\r\n}\r\n\r\n\r\n","import React, { useState } from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\n\r\n//Componente GifExpertApp\r\nconst GifExpertApp = ( ) => {\r\n\r\n    //const categories = ['One Punch', 'Samurai X', 'Dragon Ball', 'Picachu'];\r\n    //Comentamos las categorias y vamos a usar un \"hooks de useState\"\r\n    /* ¿Qué es un Hook? \r\n       Un Hook es una función especial que permite “conectarse” a características de React. \r\n       Por ejemplo, useState es un Hook que te permite añadir el estado de React a un componente de función. \r\n       Más adelante hablaremos sobre otros Hooks. */\r\n\r\n    const initialState = ['One Punch'];\r\n    const [categories, setCategories] = useState(initialState);\r\n\r\n    /* Esto lo haremos en un componente aparte\r\n    const handleAdd = () => {\r\n          //categories.push('Pacman'); no usar el push sino usar el setCategories\r\n          //console.log(categories);\r\n          //setCategories ('Pacman'); //asi no se agrega un nuevo elemento al array\r\n          \r\n          //agregar elementos a un array - modelo1\r\n          //setCategories( ['Pacman', ...categories] ); //agregando al principio\r\n          //setCategories( [...categories, 'Pacman'] ); //agregando al final\r\n          \r\n          //otra forma de agregar es usando un callback (donde el primer argumento es el estado anterior) y regresa el nuevo estado - modelo2\r\n          setCategories( cats =>  [...cats, 'Pacman'] );\r\n    }*/\r\n    \r\n    //console.log(categories);\r\n\r\n    return (\r\n        <>\r\n          <h1>GifExpertApp</h1>\r\n          <AddCategory setCategories = { setCategories } />     \r\n          \r\n          {/* <button onClick = {handleAdd}>Agregar elemento</button> */}\r\n\r\n          <ol className='category-result'>\r\n              {/* {\r\n                  categories.map( (category) => {\r\n                    //return <li key = {category}> {category} </li>  //en key no usar el indice porque es muy volatil. Se usarán \"keys\" que vengan de base de datos para optimización\r\n                    return <GifGrid category = {category} />\r\n                  })\r\n              } */}\r\n\r\n              {\r\n                categories.map( category =>  (\r\n                    <GifGrid \r\n                          key = { category }\r\n                          category = { category } \r\n                    />\r\n                ))\r\n              }\r\n\r\n          </ol>\r\n          \r\n        </>\r\n    )\r\n}\r\n\r\nexport default GifExpertApp;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport GifExpertApp from './GifExpertApp';\nimport './index.css';\n\n\n\nReactDOM.render(\n  <GifExpertApp />,\n  document.getElementById('root')\n);\n\n\n\n"],"sourceRoot":""}